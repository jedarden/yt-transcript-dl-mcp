import { VideoTranscript, TranscriptSegment, OutputFormat, FormatOptions } from '../types/index.js';

export class FormatterService {
  /**
   * Format transcript based on specified output format
   */
  format(transcript: VideoTranscript, options: FormatOptions): string {
    const { format, includeTimestamps = false, includeMetadata = false, prettify = true } = options;

    switch (format) {
      case 'text':
        return this.formatAsText(transcript, includeTimestamps, includeMetadata);
      case 'json':
        return this.formatAsJSON(transcript, prettify, includeMetadata);
      case 'srt':
        return this.formatAsSRT(transcript);
      case 'vtt':
        return this.formatAsVTT(transcript, includeMetadata);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  /**
   * Format as plain text
   */
  private formatAsText(
    transcript: VideoTranscript,
    includeTimestamps: boolean,
    includeMetadata: boolean
  ): string {
    let result = '';

    if (includeMetadata) {
      result += this.formatMetadataText(transcript);
      result += '\n' + '='.repeat(50) + '\n\n';
    }

    for (const segment of transcript.segments) {
      if (includeTimestamps) {
        const timestamp = this.formatTimestamp(segment.start);
        result += `[${timestamp}] `;
      }
      result += segment.text + '\n';
    }

    return result.trim();
  }

  /**
   * Format as JSON
   */
  private formatAsJSON(
    transcript: VideoTranscript,
    prettify: boolean,
    includeMetadata: boolean
  ): string {
    const data = includeMetadata ? transcript : {
      videoId: transcript.videoId,
      language: transcript.language,
      segments: transcript.segments
    };

    return prettify ? JSON.stringify(data, null, 2) : JSON.stringify(data);
  }

  /**
   * Format as SRT (SubRip Subtitle)
   */
  private formatAsSRT(transcript: VideoTranscript): string {
    let result = '';
    let counter = 1;

    for (const segment of transcript.segments) {
      const startTime = this.formatSRTTimestamp(segment.start);
      const endTime = this.formatSRTTimestamp(segment.start + segment.duration);
      
      result += `${counter}\n`;
      result += `${startTime} --> ${endTime}\n`;
      result += `${segment.text}\n\n`;
      counter++;
    }

    return result.trim();
  }

  /**
   * Format as WebVTT
   */
  private formatAsVTT(transcript: VideoTranscript, includeMetadata: boolean): string {
    let result = 'WEBVTT\n';

    if (includeMetadata) {
      result += `NOTE Video: ${transcript.title || transcript.videoId}\n`;
      result += `NOTE Language: ${transcript.language}\n`;
      result += `NOTE Auto-generated: ${transcript.isAutoGenerated}\n`;
      result += '\n';
    }

    for (const segment of transcript.segments) {
      const startTime = this.formatVTTTimestamp(segment.start);
      const endTime = this.formatVTTTimestamp(segment.start + segment.duration);
      
      result += `${startTime} --> ${endTime}\n`;
      result += `${segment.text}\n\n`;
    }

    return result.trim();
  }

  /**
   * Format metadata as text
   */
  private formatMetadataText(transcript: VideoTranscript): string {
    const lines = [
      `Video ID: ${transcript.videoId}`,
      `Title: ${transcript.title || 'N/A'}`,
      `Channel: ${transcript.channel || 'N/A'}`,
      `Language: ${transcript.language}`,
      `Auto-generated: ${transcript.isAutoGenerated ? 'Yes' : 'No'}`,
      `Duration: ${transcript.duration ? this.formatDuration(transcript.duration) : 'N/A'}`,
      `Fetched: ${transcript.fetchedAt.toISOString()}`
    ];

    return lines.join('\n');
  }

  /**
   * Format timestamp for text output (MM:SS or HH:MM:SS)
   */
  private formatTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  /**
   * Format timestamp for SRT (HH:MM:SS,mmm)
   */
  private formatSRTTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);

    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${millis.toString().padStart(3, '0')}`;
  }

  /**
   * Format timestamp for WebVTT (HH:MM:SS.mmm)
   */
  private formatVTTTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);

    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    const parts = [];
    if (hours > 0) parts.push(`${hours}h`);
    if (minutes > 0) parts.push(`${minutes}m`);
    if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

    return parts.join(' ');
  }

  /**
   * Merge adjacent segments with the same speaker or similar timing
   */
  mergeSegments(segments: TranscriptSegment[], maxGap: number = 0.5): TranscriptSegment[] {
    if (segments.length === 0) return [];

    const merged: TranscriptSegment[] = [];
    let current = { ...segments[0] };

    for (let i = 1; i < segments.length; i++) {
      const segment = segments[i];
      const gap = segment.start - (current.start + current.duration);

      if (gap <= maxGap) {
        // Merge segments
        current.text += ' ' + segment.text;
        current.duration = (segment.start + segment.duration) - current.start;
      } else {
        // Save current and start new
        merged.push(current);
        current = { ...segment };
      }
    }

    merged.push(current);
    return merged;
  }

  /**
   * Split long segments into smaller chunks
   */
  splitLongSegments(segments: TranscriptSegment[], maxLength: number = 100): TranscriptSegment[] {
    const result: TranscriptSegment[] = [];

    for (const segment of segments) {
      if (segment.text.length <= maxLength) {
        result.push(segment);
        continue;
      }

      // Split by sentences or words
      const words = segment.text.split(' ');
      const chunks: string[] = [];
      let currentChunk = '';

      for (const word of words) {
        if ((currentChunk + ' ' + word).length > maxLength && currentChunk) {
          chunks.push(currentChunk);
          currentChunk = word;
        } else {
          currentChunk = currentChunk ? currentChunk + ' ' + word : word;
        }
      }
      if (currentChunk) chunks.push(currentChunk);

      // Create new segments
      const chunkDuration = segment.duration / chunks.length;
      for (let i = 0; i < chunks.length; i++) {
        result.push({
          text: chunks[i],
          start: segment.start + (i * chunkDuration),
          duration: chunkDuration,
          offset: segment.offset
        });
      }
    }

    return result;
  }
}